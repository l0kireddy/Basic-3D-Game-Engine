import React, { useState, useEffect } from 'react';
import { useSceneStore } from '../store/sceneStore';
import * as THREE from 'three';

const CollisionFrameEditor = () => {
  const { selectedObject, updateObjectData, getObjectData, scene } = useSceneStore();
  const [collisionFrames, setCollisionFrames] = useState([]);
  const [editMode, setEditMode] = useState(false);
  const [selectedFrame, setSelectedFrame] = useState(null);

  useEffect(() => {
    if (selectedObject) {
      const objectData = getObjectData(selectedObject.uuid);
      if (objectData && objectData.collisionFrames) {
        setCollisionFrames(objectData.collisionFrames);
      } else {
        setCollisionFrames([]);
      }
    } else {
      setCollisionFrames([]);
    }
  }, [selectedObject, getObjectData]);

  // Auto-generate collision frame for primitive shapes
  const autoGenerateFrame = () => {
    if (!selectedObject) return;

    // Calculate bounding box
    const bbox = new THREE.Box3().setFromObject(selectedObject);
    const size = new THREE.Vector3();
    const center = new THREE.Vector3();
    bbox.getSize(size);
    bbox.getCenter(center);

    // If any frames already exist, do NOT auto-generate ‚Äî user asked for strict behavior
    if (collisionFrames && collisionFrames.length > 0) {
      console.log('Auto-generate skipped: object already has collision frames');
      return;
    }

    // Convert center to local space
    const localCenter = selectedObject.worldToLocal(center.clone());

    // Convert size into local/object space by dividing by world scale
    const worldScale = selectedObject.getWorldScale ? selectedObject.getWorldScale(new THREE.Vector3()) : new THREE.Vector3(1,1,1);
    const localSize = new THREE.Vector3(size.x, size.y, size.z).divide(worldScale);

    let frame;
    const geometryType = selectedObject.geometry ? selectedObject.geometry.type : 'BoxGeometry';

    switch (geometryType) {
      case 'SphereGeometry':
        frame = {
          id: Date.now(),
          type: 'sphere',
          position: { x: localCenter.x, y: localCenter.y, z: localCenter.z },
          radius: localSize.x / 2,
          rotation: { x: 0, y: 0, z: 0 },
          autoGenerated: true
        };
        break;
      case 'CylinderGeometry':
        frame = {
          id: Date.now(),
          type: 'cylinder',
          position: { x: localCenter.x, y: localCenter.y, z: localCenter.z },
          radius: localSize.x / 2,
          height: localSize.y,
          rotation: { x: 0, y: 0, z: 0 },
          autoGenerated: true
        };
        break;
      case 'BoxGeometry':
      default:
        frame = {
          id: Date.now(),
          type: 'box',
          position: { x: localCenter.x, y: localCenter.y, z: localCenter.z },
          size: { x: localSize.x, y: localSize.y, z: localSize.z },
          rotation: { x: 0, y: 0, z: 0 },
          autoGenerated: true
        };
        break;
    }

    const newFrames = [frame];
    setCollisionFrames(newFrames);
    updateObjectData(selectedObject.uuid, { collisionFrames: newFrames });

    console.log('Auto-generated collision frame (local-space):', frame);
  };

  // Add manual collision frame for characters/GLBs
  const addManualFrame = (type = 'box') => {
    const frame = {
      id: Date.now(),
      type: type,
      position: { x: 0, y: 0, z: 0 },
      size: { x: 1, y: 1, z: 1 },
      rotation: { x: 0, y: 0, z: 0 },
      radius: 0.5 // for sphere/capsule
    };

    const newFrames = [...collisionFrames, frame];
    setCollisionFrames(newFrames);
    updateObjectData(selectedObject.uuid, { collisionFrames: newFrames });
  };

  // Update frame properties
  const updateFrame = (frameId, property, axis, value) => {
    const newFrames = collisionFrames.map(frame => {
      if (frame.id === frameId) {
        return {
          ...frame,
          [property]: {
            ...frame[property],
            [axis]: parseFloat(value)
          }
        };
      }
      return frame;
    });

    setCollisionFrames(newFrames);
    updateObjectData(selectedObject.uuid, { collisionFrames: newFrames });
  };

  // Update frame radius (for spheres)
  const updateFrameRadius = (frameId, value) => {
    const newFrames = collisionFrames.map(frame => {
      if (frame.id === frameId) {
        return { ...frame, radius: parseFloat(value) };
      }
      return frame;
    });

    setCollisionFrames(newFrames);
    updateObjectData(selectedObject.uuid, { collisionFrames: newFrames });
  };

  // Delete frame
  const deleteFrame = (frameId) => {
    const newFrames = collisionFrames.filter(f => f.id !== frameId);
    setCollisionFrames(newFrames);
    updateObjectData(selectedObject.uuid, { collisionFrames: newFrames });
  };

  // Check if selected object is a primitive or character
  const objectData = selectedObject ? getObjectData(selectedObject.uuid) : null;
  const isPrimitive = objectData && 
    (objectData.type === 'mesh' || objectData.type === 'primitive');
  const isCharacter = objectData && 
    (objectData.type === 'gltf' || objectData.isPlayer);

  if (!selectedObject) {
    return (
      <div className="p-4 text-gray-400">
        Select an object to edit collision frames
      </div>
    );
  }

  return (
    <div className="p-4 space-y-4">
      <div className="border-b border-gray-700 pb-3">
        <h3 className="text-white font-semibold mb-2">Collision Frame Editor</h3>
        <p className="text-xs text-gray-400">
          {isPrimitive && 'Primitive shapes can auto-generate collision frames'}
          {isCharacter && 'Characters require manual collision frame placement'}
        </p>
      </div>

      {/* Action Buttons */}
      <div className="space-y-2">
        {isPrimitive && (
          <button
            onClick={autoGenerateFrame}
            className="w-full px-3 py-2 bg-green-600 hover:bg-green-700 text-white rounded text-sm font-medium transition-colors"
          >
            üéØ Auto-Generate Frame
          </button>
        )}

        {isCharacter && (
          <div className="space-y-2">
            <label className="text-xs text-gray-400">Add Manual Frame:</label>
            <div className="grid grid-cols-3 gap-2">
              <button
                onClick={() => addManualFrame('box')}
                className="px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded text-xs font-medium transition-colors"
              >
                üì¶ Box
              </button>
              <button
                onClick={() => addManualFrame('sphere')}
                className="px-3 py-2 bg-purple-600 hover:bg-purple-700 text-white rounded text-xs font-medium transition-colors"
              >
                ‚ö™ Sphere
              </button>
              <button
                onClick={() => addManualFrame('capsule')}
                className="px-3 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded text-xs font-medium transition-colors"
              >
                üíä Capsule
              </button>
            </div>
          </div>
        )}
      </div>

      {/* Collision Frames List */}
      <div className="space-y-3">
        <label className="text-sm text-gray-300 font-medium">
          Collision Frames ({collisionFrames.length})
        </label>

        {collisionFrames.length === 0 ? (
          <div className="text-xs text-gray-500 italic p-3 bg-gray-800 rounded">
            No collision frames defined
          </div>
        ) : (
          <div className="space-y-3">
            {collisionFrames.map((frame, index) => (
              <div
                key={frame.id}
                className={`p-3 rounded border ${
                  selectedFrame === frame.id
                    ? 'border-blue-500 bg-blue-900/20'
                    : 'border-gray-700 bg-gray-800'
                }`}
                onClick={() => setSelectedFrame(frame.id)}
              >
                <div className="flex items-center justify-between mb-2">
                  <span className="text-sm text-white font-medium">
                    Frame {index + 1} ({frame.type})
                  </span>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      deleteFrame(frame.id);
                    }}
                    className="px-2 py-1 bg-red-600 hover:bg-red-700 text-white rounded text-xs transition-colors"
                  >
                    üóëÔ∏è
                  </button>
                </div>

                {/* Position */}
                <div className="space-y-2">
                  <label className="text-xs text-gray-400">Position</label>
                  <div className="grid grid-cols-3 gap-2">
                    {['x', 'y', 'z'].map(axis => (
                      <div key={axis}>
                        <label className="text-xs text-gray-500">{axis.toUpperCase()}</label>
                        <input
                          type="number"
                          step="0.1"
                          value={frame.position[axis]}
                          onChange={(e) => updateFrame(frame.id, 'position', axis, e.target.value)}
                          className="w-full px-2 py-1 bg-gray-900 border border-gray-700 rounded text-white text-xs"
                        />
                      </div>
                    ))}
                  </div>
                </div>

                {/* Size (for box) or Radius (for sphere) */}
                {frame.type === 'box' && (
                  <div className="space-y-2 mt-2">
                    <label className="text-xs text-gray-400">Size</label>
                    <div className="grid grid-cols-3 gap-2">
                      {['x', 'y', 'z'].map(axis => (
                        <div key={axis}>
                          <label className="text-xs text-gray-500">{axis.toUpperCase()}</label>
                          <input
                            type="number"
                            step="0.1"
                            value={frame.size[axis]}
                            onChange={(e) => updateFrame(frame.id, 'size', axis, e.target.value)}
                            className="w-full px-2 py-1 bg-gray-900 border border-gray-700 rounded text-white text-xs"
                          />
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {(frame.type === 'sphere' || frame.type === 'capsule') && (
                  <div className="space-y-2 mt-2">
                    <label className="text-xs text-gray-400">Radius</label>
                    <input
                      type="number"
                      step="0.1"
                      value={frame.radius}
                      onChange={(e) => updateFrameRadius(frame.id, e.target.value)}
                      className="w-full px-2 py-1 bg-gray-900 border border-gray-700 rounded text-white text-xs"
                    />
                  </div>
                )}

                {frame.type === 'capsule' && (
                  <div className="space-y-2 mt-2">
                    <label className="text-xs text-gray-400">Height</label>
                    <input
                      type="number"
                      step="0.1"
                      value={frame.size?.y || 1}
                      onChange={(e) => updateFrame(frame.id, 'size', 'y', e.target.value)}
                      className="w-full px-2 py-1 bg-gray-900 border border-gray-700 rounded text-white text-xs"
                    />
                  </div>
                )}

                {/* Rotation */}
                <div className="space-y-2 mt-2">
                  <label className="text-xs text-gray-400">Rotation (degrees)</label>
                  <div className="grid grid-cols-3 gap-2">
                    {['x', 'y', 'z'].map(axis => (
                      <div key={axis}>
                        <label className="text-xs text-gray-500">{axis.toUpperCase()}</label>
                        <input
                          type="number"
                          step="1"
                          value={frame.rotation[axis]}
                          onChange={(e) => updateFrame(frame.id, 'rotation', axis, e.target.value)}
                          className="w-full px-2 py-1 bg-gray-900 border border-gray-700 rounded text-white text-xs"
                        />
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Edit Mode Toggle */}
      <div className="pt-3 border-t border-gray-700">
        <label className="flex items-center space-x-2 cursor-pointer">
          <input
            type="checkbox"
            checked={editMode}
            onChange={(e) => setEditMode(e.target.checked)}
            className="w-4 h-4"
          />
          <span className="text-sm text-gray-300">
            Show collision frames in viewport
          </span>
        </label>
      </div>

      {/* Info */}
      <div className="text-xs text-gray-500 p-3 bg-gray-800 rounded">
        üí° Tip: Collision frames define the physical boundaries for collision detection.
        Position and size them to match the visual model.
      </div>
    </div>
  );
};

export default CollisionFrameEditor;
